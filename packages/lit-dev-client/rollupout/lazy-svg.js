import{s as t,$ as e,w as o,r as s,e as i,t as r,a,n as l}from"./lit.js";import{o as d}from"./hydrate-common-components.js";var h=Object.defineProperty,n=Object.getOwnPropertyDescriptor,p=(t,e,o,s)=>{for(var i,r=s>1?void 0:s?n(e,o):e,a=t.length-1;a>=0;a--)(i=t[a])&&(r=(s?i(e,o,r):i(r))||r);return s&&r&&h(e,o,r),r};let g=class extends t{constructor(){super(...arguments),this.href="",this.label="",this.svgAriaHidden=!1,this.svgRole="",this.loading="idle",this.rootMargin="0px 0px 100px 0px",this._shouldLoad=!1,this._onIdle=()=>{this._shouldLoad=!0}}willUpdate(){"eager"===this.loading&&(this._shouldLoad=!0)}render(){return e`<svg aria-hidden="${this.svgAriaHidden?"true":o}" aria-label="${this.label?this.label:o}" role="${this.svgRole?this.svgRole:o}" part="svg"><use href="${this._shouldLoad?this.href:o}"></use></svg>`}updated(t){t.has("loading")&&("idle"===this.loading?d(this._onIdle):"visible"===this.loading&&this._visibleLoad()),super.updated(t)}_visibleLoad(){const t=new IntersectionObserver((([e])=>{e.isIntersecting&&(this._shouldLoad=!0,t.disconnect())}),{rootMargin:this.rootMargin});t.observe(this._svgEl)}};g.styles=s`:host{display:contents}`,p([i()],g.prototype,"href",2),p([i()],g.prototype,"label",2),p([i({type:Boolean,attribute:"svg-aria-hidden"})],g.prototype,"svgAriaHidden",2),p([i({attribute:"svg-role"})],g.prototype,"svgRole",2),p([i()],g.prototype,"loading",2),p([i({attribute:"root-margin"})],g.prototype,"rootMargin",2),p([r()],g.prototype,"_shouldLoad",2),p([a("svg")],g.prototype,"_svgEl",2),g=p([l("lazy-svg")],g);export{g as default};
